# 画面闪烁

前一帧没有绘制完就执行下一帧 导致画面闪烁

# 双缓冲法

## 利用系统函数（较复杂）

### 示例代码

```cpp
//创建两个HDC数据结构，前者用作获取当前窗口的绘图设备，后者用作获取内存的绘图设备
HDC current_hdc = NULL, buffer_hdc = NULL;
//这个HDC结构 用作读取磁盘中的图片
HDC srcDC = NULL;
//创建两个IMAGE对象，前者存前景（人物），后者存（背景）
IMAGE fore = NULL, back = NULL;
//获取当前窗口DC
current_hdc = GetDC(GetHWnd());
//获取内存DC
buffer_hdc = CreateCompatibleDC(NULL);
//创建与指定的设备环境相关的设备兼容的位图
HBITMAP bmp = CreateCompatibleBitmap(current_hdc, fbreadth, fheight);
//用bmp替换内存DC中的位图
SelectObject(buffer_hdc, bmp);
//读取背景到srcDC
loadimage(&back, “背景路径”);
srcDC = GetImageHDC(&back);
//将背景绘入内存DC
TransparentBlt(buffer_hdc, 0, 0, 前景宽度, 前景高度, srcDC, 前景图片左上角横坐标, 前景图片左上角纵坐标, 前景宽度, 前景高度, 0x000000);
//将前景载入srcDC，注意这时的srcDC已经和之前的背景没有任何关系了
loadimage(&fore, “前景路径”);
srcDC = GetImageHDC(&fore);
//将前景绘入内存DC
TransparentBlt(buffer_hdc, 0, 0, 前景宽度, 前景高度, srcDC, 0, 0, 前景宽度, 前景高度, 0x000000);

//将内存DC中的图像按以像素为单位，绘入当前绘图窗口
BitBlt(current_hdc, 前景图片左上角横坐标, 前景图片左上角纵坐标, 前景宽度, 前景高度, buffer_hdc, 0, 0, SRCCOPY);

//释放内存
DeleteDC(buffer_hdc);
DeleteDC(current_hdc);
DeleteDC(srcDC);
DeleteObject(bmp);

```

### 说明

- **创建两个HDC数据结构**：
    - `HDC current_hdc = NULL, buffer_hdc = NULL;`
    - `current_hdc` 用于获取当前窗口的绘图设备，`buffer_hdc` 用于获取内存的绘图设备。
- **创建用于读取磁盘图片的HDC**：
    - `HDC srcDC = NULL;`
- **创建两个IMAGE对象**：
    - `IMAGE fore = NULL, back = NULL;`
    - `fore` 用于存储前景图像（例如人物），`back` 用于存储背景图像。
- **获取当前窗口DC**：
    - `current_hdc = GetDC(GetHWnd());`
- **获取内存DC**：
    - `buffer_hdc = CreateCompatibleDC(NULL);`
- **创建与设备环境相关的位图，并用它替换内存DC中的位图**：
    - `HBITMAP bmp = CreateCompatibleBitmap(current_hdc, fbreadth, fheight);`
    - `SelectObject(buffer_hdc, bmp);`
- **读取背景图片到srcDC**：
    - `loadimage(&back, "背景路径");`
    - `srcDC = GetImageHDC(&back);`
- **将背景绘入内存DC**：
    - `TransparentBlt(buffer_hdc, 0, 0, 前景宽度, 前景高度, srcDC, 前景图片左上角横坐标, 前景图片左上角纵坐标, 前景宽度, 前景高度, 0x000000);`
- **将前景载入srcDC**：
    - `loadimage(&fore, "前景路径");`
    - 注意：此时的 `srcDC` 已与之前的背景无关。
    - `srcDC = GetImageHDC(&fore);`
- **将前景绘入内存DC**：
    - `TransparentBlt(buffer_hdc, 0, 0, 前景宽度, 前景高度, srcDC, 0, 0, 前景宽度, 前景高度, 0x000000);`
- **将内存DC中的图像绘入当前窗口**：
    - `BitBlt(current_hdc, 前景图片左上角横坐标, 前景图片左上角纵坐标, 前景宽度, 前景高度, buffer_hdc, 0, 0, SRCCOPY);`
- **释放内存**：
    - `DeleteDC(buffer_hdc);`
    - `DeleteDC(current_hdc);`
    - `DeleteDC(srcDC);`
    - `DeleteObject(bmp);`

## 利用EasyX方法（很简单）

通过 EasyX 的 `BeginBatchDraw` 和 `EndBatchDraw` 函数，我们可以轻松实现双缓冲技术，从而避免屏幕闪烁。下面是一个使用 EasyX 实现双缓冲动画的示例代码：

### 示例代码

```cpp
#include <bits/stdc++.h>
#include <graphics.h>
#include <conio.h>
#include <filesystem>

#include "windowCfg.h"
#include "imgCfg.h"
#include "levelCfg.h"
#include "Object.h"

#define HEIGHT 240
#define WIDTH 320

using namespace std;
namespace fs = std::filesystem;

void loadingImage(const vector<Images>& images) {
    for (int i = 0; i < images.size(); i++) {
        loadimage(images[i].name, _T(IMG_BG_START_MENU), images[i].width * scaleFactor, images[i].height * scaleFactor);
    }
}

int main() {
    bool running = true;

    loadingImage(images);

    initgraph(WIDTH * scaleFactor, HEIGHT * scaleFactor);
    setbkcolor(BLACK);
    cleardevice();

    outtext(_T("Hello World!"));
    putimage(0, 0, &bg_start_menu);

    TextObject bt_startGame(35, 155, true, _T("Start Game"), TextObject::FONT_KURLAND, 20, RGB(255, 255, 0));
    TextObject bt_highScore(35, 175, true, _T("High Score"), TextObject::FONT_KURLAND, 20, RGB(255, 255, 0));

    while (running) {
        // 开始批量绘图
        BeginBatchDraw();

        // 清除设备并绘制背景图片
        cleardevice();
        putimage(0, 0, &bg_start_menu);

        // 处理鼠标事件
        MOUSEMSG mouseMsg = GetMouseMsg();
        bt_startGame.handleMouseEvent(mouseMsg);
        bt_highScore.handleMouseEvent(mouseMsg);

        // 渲染文本对象
        bt_startGame.render();
        bt_highScore.render();

        // 结束批量绘图并更新屏幕
        EndBatchDraw();

        // 检测 ESC 键是否按下
        if (GetAsyncKeyState(VK_ESCAPE) & 0x8000) {
            running = false;
        }

        // 延时以减少 CPU 使用率
        Sleep(1);
    }
    closegraph();

    return 0;
}

```

### 说明

1. **初始化图形窗口**：调用 `initgraph` 函数初始化一个 800x600 像素的图形窗口。
2. **定义运动物体的初始位置和速度**：设置物体的初始坐标 `x`、`y` 以及速度 `vx`、`vy`。
3. **主循环**：在主循环中实现双缓冲动画：
    - 使用 `BeginBatchDraw` 开始批量绘图。
    - 使用 `cleardevice` 清除屏幕。
    - 绘制背景和运动物体。
    - 更新物体的位置，并处理碰撞反弹。
    - 使用 `EndBatchDraw` 结束批量绘图并更新屏幕。
4. **处理ESC键按下事件**：检测 `ESC` 键按下时退出循环。
5. **延时**：使用 `Sleep` 函数延时以减少CPU使用率。
6. **关闭图形窗口**：退出主循环后，调用 `closegraph` 函数关闭图形窗口。